---
title: Forethought and Planning
layout: post
image: http://www.roarlocal.com.au/wp-content/uploads/2013/06/why-are-you-so-dumb.jpg
tags:
- blog
---

I’m a stupid programmer. I almost never sit down before I actually start writing code and just go at it. I recently learned, the good ol’ hard way, why you should do this. Even for just a few minutes.

A programmer, through the use of arcane symbols and implements known as compilers or interpreters, tell a computer to do different things. This can be anything: a video game with weird puzzles, a bit of data that tells another program how to improve its look and function, or a simple web app that made my trig homework all too easy.

![Magic][magic_gif]

Every once in a while, a programmer can get really stuck. This can happen for a variety of reasons: a tricky problem that you can’t quite put into words for Google or StackOverflow to find the answer, wanting to figure out a more flexible and/or reusable way to refactor already-functional code, or trying to solve a problem a really stupid way and not stepping back to see if there’s a better approach to this kind of problem. 

I recently ran into issues with the latter

I worked for a company called emfluence. There’s a small team of software engineers here who mostly do web development and we tend to take a break every other day or so and play a game, whether that’s Mario Kart, Smash Bros., or a simple dice game. 

One of those days we ended playing a game called Farkle. It was a very simple game where you roll dice and earn points based on arbitrary rolls or combinations. I instantly liked the game as there was a simple element of chance (dice rolls) and a simple element of strategy (statistics and probability), though some would argue that statistics and probability isn’t quite strategy. It was simple, fun, quick, and rewarding. 

![Farkle][farkle_pic]

The goal is to reach 10,000 points. You can’t get any points until you have 1,000. Farkle, like many old dice games, has many scoring variations, but we played as follows: a 1 is 100 points, a 5 is 50 points, three-of-a-kind was the number times 100 points (except 1's, which were 1,000 points), four-of-a-kind was 1,000 points (except 1's which were 2,000), five-of-a-kind was 2,000 points (except 1's which were 3,000), six-of-a-kind was 3,000 points (except 1's which were 4,000), and a straight (rolling one of each number, 1 through 6) was 2500 points. You start every turn rolling six 6-sided dice. 

Every roll, you would assess the dice and figure out which scoring options you had. Whichever dice you didn’t keep for that roll as points, you re-rolled. If you ever couldn’t keep any dice as points, you lost all your points for that round and would “bust.” You stopped whenever you were satisfied with your score or were afraid of “busting” on the next roll. If you managed to use all six dice as points, you could roll again with all 6, keeping whatever points you managed to earn. This meant you could keep rolling 1's and 5's and keep on going until… you didn’t.

After my boss proclaimed the game was more fun if you had to take a shot every time you busted, he was suddenly busting every other round.

We quickly decided if you roll and have a bunch of 1's and 5's, it was better to just keep only one of the 1's and roll the rest for a better chance of getting the bigger points with the many-of-a-kinds. It was also best, at the start, since you needed at least 1,000 points to even get started, you might as well keep risking the bust in order to get that first 1,000. The same was observed when somebody hit 10,000 and everybody else got one last roll to beat the top score; since you were behind, you might as well keep rolling until you won, as the worst case scenario was losing… which you already were.

On the surface, the game had simple rules. Simple enough that I should be able to write a program that can play the game. If I could do that, I could run tests and see what strategies work best. I have an obsession with rules and finding ways to exploit them. While this has proven to have negative side effects, especially when growing up, it’s pretty handy as a programmer since the way my mind naturally flows through thoughts under these pretenses complements the way one solves problems with a computer. 

So, that evening, I got started. I whipped up a quick python script and had a very basic system. Generate six random numbers, sort them ascending into a string so that similar numbers were adjacent, check if that string contained any of the strings that were “scoring,” such as “111" for 1,000 points, etc. 

The critical functions are shown below.

{% highlight python %}
import random

def get_dice_roll(n = 6):
	"""Generate a sorted, n-length string containing the result of nd6."""
	roll = []
	for i in range(n):
	   roll.append(str(random.randint(1, 6)))
	roll.sort()
	return ''.join(roll)

def get_scores(roll):
	"""Return a dictionary with the scores found in a roll where the keys are
	the scoring sets found and the values are the points worth."""
	scores = {}
	for combo in score_table:
		if combo in roll:
			scores[combo] = score_table[combo]
	return scores

def turn():
	"""Simulate a player's turn."""
	points = 0
	busted = False
	stopped = False
	num_dice = 6
	
	while not busted and not stopped:
		if points > 0:
			# ... Check if user wants to stop
				stopped = true
				break

		current_roll = roll(num_dice)
		score_options = scores(current_roll)

		if len(score_options) < 1:
			busted = True
			break
			
		# ... Let user choose scoring option
		
		points += score_options[choice]
		num_dice -= len(choice)
		if num_dice == 0: 
			num_dice = 6

	# Display results
{% endhighlight %}

However, I quickly ran into a problem.

If somebody had, say, 4 dice left and rolled three 6's and a 1. Obviously, you’d want to take both and get 700 points and the option to re-roll all 6 dice. But with my initial prototype, I could only detect the three 6's or the single one. I would need to check for all score combinations and not just individual scores.

So I got started. With my current program just checking if a string contained an individual scoring set, this was obviously a terrible way to approach what I needed to accomplish, but we programmers like to try to reuse code, and I’m especially stubborn and narrow-minded. So I trudged on.

The first and most obvious of the stupid options was to generate a table with every possible scoring combination. But I didn’t want to do this. Since Farkle had varying scorings, I wanted to be able to quickly modify individual entries in my substring -> score table and not regenerate a whole table of the different combinations.

This ends up still being a bit silly, though, as many Farkle variations allow for three pairs, which my current system doesn’t exactly support (short of adding every combination of “112233", “112244", “112255", “112266", “113344", etc.). So I could still do some work. 

Anyways, my second stupid thought was iterating the score table twice, and checking every score twice and combining them. Obviously, though, this still wouldn’t work if there were combinations of more than two. 

I then (embarassingly) collected all the substring positions (index, length) and stored them in the key of the score dictionary and performed *collision detection* to check for invalid intersections to check if they could coexist. I'm sure this could work, but I didn't get it to. Plus, as I was writing it I was feeling dumber and dumber. 

So I tried iteration upon iteration of different but similarly idiotic approaches. I burned quite a few evenings before I got annoyed enough to stop looking at my code, start a new file and from the ground up, rewrite the stupid thing. 

I didn't write any code yet. I wrote out, in English, what I wanted to accomplish. Then I wrote out, in English, how I thought I could go about doing that. 

    Goal:
    Calculate all Farkle roll score options.

    Method: 
    ???

I didn't get very far. Forcing myself to write the solution out with words turned out to be a pretty great idea!

I stopped to think. Obviously, sitting at the table actually playing the game I could figure out all my options very quickly... how did I mentally achieve this? 

Well, on the table, I would roll the dice, partition off any high points to keep, check the rest for any other points I might want, and that was it. So mentally, I didn't really consider every option. I would take the most valuable roll that wasn't a 1 or 5, a single 1, or a single 5 unless I could get all my remaining dice off at once. 

So that wasn't much help... initially. I didn't ever really think of every possible combination unless I could get all 6 dice off. 

But I very quickly made the connection of partitioning off good dice and realized I could easily do something similar. The solution became pretty clear after just a few minutes of thinking: recursively check every score entry against the roll string, removing that score entry from the roll string. 

    # Goal

    Calculate Farkle roll score options given a single Farkle roll. 

    # Method

    * Create a dictionary where every key is the required roll set and the value 
        is the point value of that scoring dice set. 
    * Convert the roll data into a string sorted ascending where each character is
        the character '1' through '6'.
    * Iterate the scoring sets dictionary.
      * Check if the current set exists in the roll. If it doesn't, continue on
          to the next set. 
      * If the current set exists, add it to the list of valid, current scores 
          and recursively run the scoring method on the string with the scoring 
          set removed from the roll
      * Combine the current set with all scores resulting from the recursive 
          call. 
    * You now have the scores, you moron.

Man I felt so dumb. I quickly wrote this bit of code.

{% highlight python %}
def get_score_options(roll): 
	score_options = {}

	initial_options = get_scores(roll)
	for combo in initial_options:
		score_options[combo] = initial_options[combo]

		sub_scores = get_score_options(roll.replace(combo, '' , 1))
		for sub_combo in sub_scores:
			# Prevents duplicate combinations and sorts the combined keys 
			# ascending by points.
			if sub_scores[sub_combo] < score_options[combo]: continue 
			score_options[combo + ", " + sub_combo] = score_options[combo] \
				+ sub_scores[sub_combo]

	return score_options
{% endhighlight %}

Many man-hours spent on something that which, with a little pre-thought, took me about ten minutes.

And that, kids, is why you stop, think, and then do. Don't always do and think along the way. A little pre-thought can (apparently) go a very long way. 

Oh, here's my `score_table` in case you wanted it.

{% highlight python %}
score_table = {
	"5": 50, 
	"1": 100, 
	"222": 200,
	"333": 300, 
	"444": 400,
	"555": 500,
	"666": 600,
	"111": 1000, 
	"2222": 1000, 
	"3333": 1000, 
	"4444": 1000, 
	"5555": 1000, 
	"6666": 1000,
	"1111": 2000, 
	"22222": 2000, 
	"33333": 2000, 
	"44444": 2000, 
	"55555": 2000, 
	"66666": 2000, 
	"11111": 3000, 
	"123456": 2500,
	"222222": 3000, 
	"333333": 3000, 
	"444444": 3000, 
	"555555": 3000, 
	"666666": 3000, 
	"111111": 4000, 
}
{% endhighlight %}


[so_dumb]: http://www.roarlocal.com.au/wp-content/uploads/2013/06/why-are-you-so-dumb.jpg
[magic_gif]: http://weknowgifs.com/wp-content/uploads/2013/03/its-magic-shia-labeouf-gif.gif
[farkle_pic]: http://ecx.images-amazon.com/images/I/71KeRAuQ2uL._SL1000_.jpg
